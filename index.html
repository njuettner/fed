<!DOCTYPE html>
<html>
<head>
    <title>Fed Data Collection</title>
    <meta charset="UTF-8" />
    <!-- Load Chart.js first -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <!-- Then load Luxon -->
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.0.1/build/global/luxon.min.js"></script>
    <!-- Then load Chart.js adapter for Luxon -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.0.0/dist/chartjs-adapter-luxon.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet" />
    <style>
        body.dark-mode {
            background-color: #121212;
            color: #ffffff;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        body {
            font-family: "Roboto", sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #ffffff; /* Light mode preferred */
            color: #333333;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        h1 {
            margin-top: 0;
            text-align: center;
        }
        .header-container {
            text-align: center;
            margin-bottom: 20px;
        }
        .chart-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 30px; /* Increased spacing */
            justify-content: center;
        }
        .chart-container {
            width: 45%;
            background: #f5f5f5;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: background 0.3s ease, box-shadow 0.3s ease;
            height: 300px; /* Fixed height for charts */
            position: relative;
        }
        body.dark-mode .chart-container {
            background-color: #1e1e1e;
            box-shadow: 0 2px 8px rgba(255,255,255,0.1);
        }
        /* Improved toggle switch */
        .toggle-switch {
            position: fixed;
            right: 20px;
            top: 20px;
            width: 60px;
            height: 34px;
            background: #cccccc; /* Light gray toggle switch */
            border-radius: 34px;
            cursor: pointer;
            transition: background 0.3s ease;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        body.dark-mode .toggle-switch {
            background: #888888; /* Darker toggle switch in dark mode */
        }
        .toggle-switch input {
            display: none;
        }
        .toggle-switch label {
            display: block;
            width: 26px;
            height: 26px;
            background: #ffffff; /* White knob for contrast */
            border-radius: 50%;
            position: absolute;
            top: 4px;
            left: 4px;
            transition: transform 0.2s ease, background 0.3s ease;
        }
        .toggle-switch input:checked + label {
            transform: translateX(26px);
            background: #ffffff; /* White knob remains white when toggled */
        }
        /* Remove default legends */
        .chart-container canvas {
            max-height: 100%;
        }
        /* Custom Legend Styling */
        .chart-legend {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        .chart-legend span {
            margin: 0 10px;
            font-size: 14px;
            display: flex;
            align-items: center;
        }
        .chart-legend span::before {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            background-color: currentColor;
            margin-right: 5px;
            border-radius: 2px;
        }
        /* Loading Spinner */
        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 4px solid rgba(0,0,0,0.1);
            border-top: 4px solid #555555;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        body.dark-mode .loading-spinner {
            border-top: 4px solid #ffffff;
        }
        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        /* Error Message Styling */
        .error-message {
            color: #ff4d4d;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header-container">
        <h1>Fed Data Collection</h1>
    </div>

    <!-- Toggle Switch -->
    <div class="toggle-switch">
        <input type="checkbox" id="darkToggle" aria-label="Toggle Dark Mode" />
        <label for="darkToggle"></label>
    </div>

    <!-- Charts Grid -->
    <div id="charts" class="chart-grid">
        <!-- Chart containers will be dynamically inserted here -->
    </div>

    <script>
        // Store chart instances
        window.charts = [];

        // Toggle the dark mode
        document.getElementById('darkToggle').addEventListener('change', () => {
            document.body.classList.toggle('dark-mode');
            updateChartsTheme();
        });

        // Function to update charts' colors based on theme
        const updateChartsTheme = () => {
            const isDark = document.body.classList.contains('dark-mode');
            Chart.defaults.color = isDark ? '#ffffff' : '#333333';
            Chart.defaults.borderColor = isDark ? '#ffffff' : '#333333';

            window.charts.forEach(chart => {
                chart.data.datasets.forEach(dataset => {
                    dataset.backgroundColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(137,170,255, 0.2)';
                    dataset.borderColor = isDark ? '#ffffff' : '#1355FF';
                    dataset.pointBackgroundColor = isDark ? '#ffffff' : '#1355FF';
                    dataset.pointBorderColor = isDark ? '#ffffff' : '#1355FF';
                    dataset.pointHoverBackgroundColor = isDark ? '#ffffff' : '#1355FF';
                    dataset.pointHoverBorderColor = isDark ? '#ffffff' : '#1355FF';
                });
                // Update scales
                chart.options.scales.x.ticks.color = isDark ? '#ffffff' : '#333333';
                chart.options.scales.y.ticks.color = isDark ? '#ffffff' : '#333333';
                chart.options.scales.x.grid.color = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0,0,0,0.05)';
                chart.options.scales.y.grid.color = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0,0,0,0.05)';
                // Update legend
                chart.options.plugins.legend.labels.color = isDark ? '#ffffff' : '#333333';
                chart.update();
            });
        };

        // Function to create a chart for a single JSON file
        const createChart = (data, chartId, label, startDate, endDate) => {
            // Check if dark mode is active
            const isDark = document.body.classList.contains('dark-mode');
            const backgroundColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(137,170,255, 0.2)';
            const borderColor = isDark ? '#ffffff' : '#1355FF';

            // Show loading spinner
            const chartContainer = document.getElementById(chartId).parentNode;
            const spinner = document.createElement('div');
            spinner.className = 'loading-spinner';
            chartContainer.appendChild(spinner);

            // Extract data from observations within the specified time range
            let observations = data.observations;
            if (startDate || endDate) {
                observations = observations.filter(obs => {
                    const obsDate = new Date(obs.date);
                    let afterStart = true;
                    let beforeEnd = true;
                    if (startDate) {
                        afterStart = obsDate >= new Date(startDate);
                    }
                    if (endDate) {
                        beforeEnd = obsDate <= new Date(endDate);
                    }
                    return afterStart && beforeEnd;
                });
            }

            const labels = observations.map(obs => obs.date);
            const values = observations.map(obs => Number(obs.value));

            // Create chart using Chart.js
            const ctx = document.getElementById(chartId).getContext('2d');
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: values,
                        backgroundColor: backgroundColor,
                        borderColor: borderColor,
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4, // Makes the lines more curved and smooth
                        pointRadius: 3,
                        pointBackgroundColor: borderColor,
                        pointBorderColor: borderColor,
                        pointHoverRadius: 5,
                        pointHoverBackgroundColor: borderColor,
                        pointHoverBorderColor: borderColor,
                    }]
                },
                options: {
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day'
                            },
                            min: startDate || undefined, // Set minimum date if specified
                            max: endDate || undefined,   // Set maximum date if specified
                            ticks: {
                                color: isDark ? '#ffffff' : '#333333'
                            },
                            grid: {
                                color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0,0,0,0.05)'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: isDark ? '#ffffff' : '#333333'
                            },
                            grid: {
                                color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0,0,0,0.05)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false // Hide the default legend
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    responsive: true,
                    maintainAspectRatio: false
                }
            });

            // Remove loading spinner
            chartContainer.removeChild(spinner);

            // Create a custom legend
            const legend = document.createElement('div');
            legend.className = 'chart-legend';
            const legendItem = document.createElement('span');
            legendItem.textContent = label;
            legend.style.color = borderColor;
            legend.appendChild(legendItem);
            chartContainer.appendChild(legend);

            window.charts.push(chart);
        };

        const dataDir = 'data/';

        // Fetch the files list from files.json
        fetch(`${dataDir}files.json`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                const files = data.files;

                // Create placeholder chart containers
                files.forEach(file => {
                    let chartDiv = document.createElement('div');
                    chartDiv.className = 'chart-container';
                    chartDiv.setAttribute('data-file', file.name);
                    chartDiv.setAttribute('data-label', file.label);
                    chartDiv.setAttribute('data-start-date', file.startDate); // Optional
                    chartDiv.setAttribute('data-end-date', file.endDate);     // Optional
                    chartDiv.innerHTML = `<canvas id="${file.name.replace('.json', 'Chart')}"></canvas>`;
                    document.getElementById('charts').appendChild(chartDiv);
                });

                // IntersectionObserver callback
                const onIntersection = (entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const chartDiv = entry.target;
                            const fileName = chartDiv.getAttribute('data-file');
                            const label = chartDiv.getAttribute('data-label');
                            const chartId = fileName.replace('.json', 'Chart');
                            const startDate = chartDiv.getAttribute('data-start-date');
                            const endDate = chartDiv.getAttribute('data-end-date');

                            // Check if chart is already initialized
                            if (!chartDiv.getAttribute('data-loaded')) {
                                // Show loading spinner
                                const spinner = document.createElement('div');
                                spinner.className = 'loading-spinner';
                                chartDiv.appendChild(spinner);

                                fetch(dataDir + fileName)
                                    .then(response => {
                                        if (!response.ok) {
                                            throw new Error(`HTTP error! status: ${response.status}`);
                                        }
                                        return response.json();
                                    })
                                    .then(chartData => {
                                        createChart(chartData, chartId, label, startDate, endDate);
                                        chartDiv.setAttribute('data-loaded', 'true'); // Mark as loaded
                                    })
                                    .catch(error => {
                                        console.error(`Failed to load ${fileName}: `, error);
                                        // Display an error message in the UI
                                        chartDiv.innerHTML = `<p class="error-message">Error loading ${label}</p>`;
                                    });

                                // Stop observing this chartDiv
                                observer.unobserve(chartDiv);
                            }
                        }
                    });
                };

                // Create an IntersectionObserver
                const observerOptions = {
                    root: null, // viewport
                    rootMargin: '0px',
                    threshold: 0.1 // 10% of the element is visible
                };
                const observer = new IntersectionObserver(onIntersection, observerOptions);

                // Observe each chart container
                document.querySelectorAll('.chart-container').forEach(chartDiv => {
                    observer.observe(chartDiv);
                });

                // Initialize the toggle switch based on user's preference (optional)
                // For example, save preference in localStorage
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme) {
                    if (savedTheme === 'dark') {
                        document.body.classList.add('dark-mode');
                        document.getElementById('darkToggle').checked = true;
                    } else {
                        document.body.classList.remove('dark-mode');
                        document.getElementById('darkToggle').checked = false;
                    }
                }

                // Update localStorage when theme is toggled
                document.getElementById('darkToggle').addEventListener('change', () => {
                    if (document.body.classList.contains('dark-mode')) {
                        localStorage.setItem('theme', 'dark');
                    } else {
                        localStorage.setItem('theme', 'light');
                    }
                });
            })
            .catch(error => {
                console.error('Failed to load files.json:', error);
                // Optionally display an error message in the UI
                document.getElementById('charts').innerHTML = `<p class="error-message">Failed to load chart configurations.</p>`;
            });
    </script>
</body>
</html>
